# Step 1: Learn the Basics (31 problems: 29 solved, 2 unsolved)

## Lec 1: Things to Know in C++/Java/Python (9/9 ✅)
| # | Problem | Solved | Difficulty |
|---|---------|--------|-----------|
| 1.1.1.1 | User Input / Output | ✅ | Easy |
| 1.1.1.2 | Data Types | ✅ | Easy |
| 1.1.1.3 | If Else statements | ✅ | Easy |
| 1.1.1.4 | Switch Statement | ✅ | Easy |
| 1.1.1.5 | What are arrays, strings? | ✅ | Easy |
| 1.1.1.6 | For loops | ✅ | Easy |
| 1.1.1.7 | While loops | ✅ | Easy |
| 1.1.1.8 | Functions (Pass by Reference and Value) | ✅ | Easy |
| 1.1.1.9 | Time Complexity [Learn Basics] | ✅ | Easy |

## Lec 2: Build-up Logical Thinking (1/1 ✅)
| # | Problem | Solved | Difficulty |
|---|---------|--------|-----------|
| 1.2.1.1 | Patterns | ✅ | Easy |

## Lec 3: Learn STL/Java-Collections (0/2 ❌)
| # | Problem | Solved | Difficulty |
|---|---------|--------|-----------|
| 1.3.1.1 | C++ STL | ❌ | Medium |
| 1.3.1.2 | Java Collections | ❌ | Easy |

## Lec 4: Know Basic Maths (7/7 ✅)
| # | Problem | Solved | Difficulty |
|---|---------|--------|-----------|
| 1.4.1.1 | Count Digits | ✅ | Easy |
| 1.4.1.2 | Reverse a Number | ✅ | Easy |
| 1.4.1.3 | Check Palindrome | ✅ | Easy |
| 1.4.1.4 | GCD Or HCF | ✅ | Easy |
| 1.4.1.5 | Armstrong Numbers | ✅ | Easy |
| 1.4.1.6 | Print all Divisors | ✅ | Easy |
| 1.4.1.7 | Check for Prime | ✅ | Easy |

## Lec 5: Learn Basic Recursion (9/9 ✅)
| # | Problem | Solved | Difficulty |
|---|---------|--------|-----------|
| 1.5.1.1 | Understand recursion by print something N times | ✅ | Easy |
| 1.5.1.2 | Print name N times using recursion | ✅ | Easy |
| 1.5.1.3 | Print 1 to N using recursion | ✅ | Easy |
| 1.5.1.4 | Print N to 1 using recursion | ✅ | Easy |
| 1.5.1.5 | Sum of first N numbers | ✅ | Easy |
| 1.5.1.6 | Factorial of N numbers | ✅ | Easy |
| 1.5.1.7 | Reverse an array | ✅ | Easy |
| 1.5.1.8 | Check if a string is palindrome or not | ✅ | Medium |
| 1.5.1.9 | Fibonacci Number | ✅ | Easy |

## Lec 6: Learn Basic Hashing (3/3 ✅)
| # | Problem | Solved | Difficulty |
|---|---------|--------|-----------|
| 1.6.1.1 | Hashing Theory | ✅ | Medium |
| 1.6.1.2 | Counting frequencies of array elements | ✅ | Easy |
| 1.6.1.3 | Find the highest/lowest frequency element | ✅ | Easy |

---

# Step 2: Learn Important Sorting Techniques (5/7)

## Lec 1: Sorting-I (3/3 ✅)
| # | Problem | Solved | Difficulty |
|---|---------|--------|-----------|
| 2.1.1.1 | Selection Sort | ✅ | Easy |
| 2.1.1.2 | Bubble Sort | ✅ | Easy |
| 2.1.1.3 | Insertion Sort | ✅ | Easy |

## Lec 2: Sorting-II (2/4)
| # | Problem | Solved | Difficulty |
|---|---------|--------|-----------|
| 2.2.1.1 | Merge Sort | ✅ | Medium |
| 2.2.1.2 | Recursive Bubble Sort | ❌ | Easy |
| 2.2.1.3 | Recursive Insertion Sort | ❌ | Easy |
| 2.2.1.4 | Quick Sort | ✅ | Easy |

---

# Step 3: Solve Problems on Arrays [Easy -> Medium -> Hard] (29/40)

## Lec 1: Easy (14/14 ✅)
| # | Problem | Solved | Difficulty |
|---|---------|--------|-----------|
| 3.1.1.1 | Largest Element in an Array | ✅ | Easy |
| 3.1.1.2 | Second Largest Element in an Array without sorting | ✅ | Easy |
| 3.1.1.3 | Check if the array is sorted | ✅ | Easy |
| 3.1.1.4 | Remove duplicates from Sorted array | ✅ | Easy |
| 3.1.1.5 | Left Rotate an array by one place | ✅ | Easy |
| 3.1.1.6 | Left rotate an array by D places | ✅ | Easy |
| 3.1.1.7 | Move Zeros to end | ✅ | Easy |
| 3.1.1.8 | Linear Search | ✅ | Easy |
| 3.1.1.9 | Find the Union | ✅ | Medium |
| 3.1.1.10 | Find missing number in an array | ✅ | Easy |
| 3.1.1.11 | Maximum Consecutive Ones | ✅ | Easy |
| 3.1.1.12 | Find the number that appears once, and other numbers twice | ✅ | Medium |
| 3.1.1.13 | Longest subarray with given sum K(positives) | ✅ | Medium |
| 3.1.1.14 | Longest subarray with sum K (Positives + Negatives) | ✅ | Medium |

## Lec 2: Medium (9/14)
| # | Problem | Solved | Difficulty |
|---|---------|--------|-----------|
| 3.2.1.1 | 2Sum Problem | ✅ | Medium |
| 3.2.1.2 | Sort an array of 0's 1's and 2's | ✅ | Medium |
| 3.2.1.3 | Majority Element (>n/2 times) | ✅ | Easy |
| 3.2.1.4 | Kadane's Algorithm, maximum subarray sum | ✅ | Easy |
| 3.2.1.5 | Print subarray with maximum subarray sum | ❌ | Medium |
| 3.2.1.6 | Stock Buy and Sell | ✅ | Easy |
| 3.2.1.7 | Rearrange the array in alternating positive and negative items | ✅ | Medium |
| 3.2.1.8 | Next Permutation | ✅ | Medium |
| 3.2.1.9 | Leaders in an Array problem | ❌ | Easy |
| 3.2.1.10 | Longest Consecutive Sequence in an Array | ❌ | Easy |
| 3.2.1.11 | Set Matrix Zeros | ❌ | Medium |
| 3.2.1.12 | Rotate Matrix by 90 degrees | ❌ | Medium |
| 3.2.1.13 | Print the matrix in spiral manner | ✅ | Medium |
| 3.2.1.14 | Count subarrays with given sum | ✅ | Easy |

## Lec 3: Hard (6/12)
| # | Problem | Solved | Difficulty |
|---|---------|--------|-----------|
| 3.3.1.1 | Pascal's Triangle | ✅ | Medium |
| 3.3.1.2 | Majority Element (n/3 times) | ✅ | Medium |
| 3.3.1.3 | 3-Sum Problem | ✅ | Medium |
| 3.3.1.4 | 4-Sum Problem | ❌ | Hard |
| 3.3.1.5 | Largest Subarray with 0 Sum | ❌ | Medium |
| 3.3.1.6 | Count number of subarrays with given xor K | ❌ | Hard |
| 3.3.1.7 | Merge Overlapping Subintervals | ✅ | Medium |
| 3.3.1.8 | Merge two sorted arrays without extra space | ✅ | Medium |
| 3.3.1.9 | Find the repeating and missing number | ❌ | Hard |
| 3.3.1.10 | Count Inversions | ❌ | Hard |
| 3.3.1.11 | Reverse Pairs | ❌ | Hard |
| 3.3.1.12 | Maximum Product Subarray | ✅ | Easy |

---

# Step 4: Binary Search [1D, 2D Arrays, Search Space] (19/32)

## Lec 1: BS on 1D Arrays (13/13 ✅)
| # | Problem | Solved | Difficulty |
|---|---------|--------|-----------|
| 4.1.1.1 | Binary Search to find X in sorted array | ✅ | Easy |
| 4.1.1.2 | Implement Lower Bound | ✅ | Easy |
| 4.1.1.3 | Implement Upper Bound | ✅ | Easy |
| 4.1.1.4 | Search Insert Position | ✅ | Easy |
| 4.1.1.5 | Floor/Ceil in Sorted Array | ✅ | Medium |
| 4.1.1.6 | Find the first or last occurrence of a given number in a sorted array | ✅ | Easy |
| 4.1.1.7 | Count occurrences of a number in a sorted array with duplicates | ✅ | Easy |
| 4.1.1.8 | Search in Rotated Sorted Array I | ✅ | Medium |
| 4.1.1.9 | Search in Rotated Sorted Array II | ✅ | Medium |
| 4.1.1.10 | Find minimum in Rotated Sorted Array | ✅ | Medium |
| 4.1.1.11 | Find out how many times has an array been rotated | ✅ | Easy |
| 4.1.1.12 | Single element in a Sorted Array | ✅ | Easy |
| 4.1.1.13 | Find peak element | ✅ | Hard |

## Lec 2: BS on Answers (4/14)
| # | Problem | Solved | Difficulty |
|---|---------|--------|-----------|
| 4.2.1.1 | Find square root of a number in log n | ✅ | Medium |
| 4.2.1.2 | Find the Nth root of a number using binary search | ✅ | Medium |
| 4.2.1.3 | Koko Eating Bananas | ✅ | Hard |
| 4.2.1.4 | Minimum days to make M bouquets | ❌ | Hard |
| 4.2.1.5 | Find the smallest Divisor | ✅ | Easy |
| 4.2.1.6 | Capacity to Ship Packages within D Days | ❌ | Hard |
| 4.2.1.7 | Kth Missing Positive Number | ❌ | Easy |
| 4.2.1.8 | Aggressive Cows | ❌ | Hard |
| 4.2.1.9 | Book Allocation Problem | ❌ | Hard |
| 4.2.1.10 | Split array - Largest Sum | ❌ | Hard |
| 4.2.1.11 | Painter's partition | ❌ | Hard |
| 4.2.1.12 | Minimize Max Distance to Gas Station | ❌ | Hard |
| 4.2.1.13 | Median of 2 sorted arrays | ❌ | Hard |
| 4.2.1.14 | Kth element of 2 sorted arrays | ❌ | Medium |

## Lec 3: BS on 2D Arrays (2/5)
| # | Problem | Solved | Difficulty |
|---|---------|--------|-----------|
| 4.3.1.1 | Find the row with maximum number of 1's | ✅ | Easy |
| 4.3.1.2 | Search in a 2 D matrix | ✅ | Medium |
| 4.3.1.3 | Search in a row and column wise sorted matrix | ❌ | Medium |
| 4.3.1.4 | Find Peak Element (2D Matrix) | ❌ | Hard |
| 4.3.1.5 | Matrix Median | ❌ | Hard |

---

# Step 5: Strings [Basic and Medium] (11/15)

## Lec 1: Basic and Easy String Problems (7/7 ✅)
| # | Problem | Solved | Difficulty |
|---|---------|--------|-----------|
| 5.1.1.1 | Remove outermost Paranthesis | ✅ | Easy |
| 5.1.1.2 | Reverse words in a given string / Palindrome Check | ✅ | Easy |
| 5.1.1.3 | Largest odd number in a string | ✅ | Easy |
| 5.1.1.4 | Longest Common Prefix | ✅ | Easy |
| 5.1.1.5 | Isomorphic String | ✅ | Easy |
| 5.1.1.6 | check whether one string is a rotation of another | ✅ | Medium |
| 5.1.1.7 | Check if two strings are anagrams of each other | ✅ | Medium |

## Lec 2: Medium String Problems (4/8)
| # | Problem | Solved | Difficulty |
|---|---------|--------|-----------|
| 5.2.1.1 | Sort Characters by frequency | ✅ | Easy |
| 5.2.1.2 | Maximum Nesting Depth of Paranthesis | ✅ | Easy |
| 5.2.1.3 | Roman Number to Integer and vice versa | ✅ | Easy |
| 5.2.1.4 | Implement Atoi | ❌ | Medium |
| 5.2.1.5 | Count Number of Substrings | ❌ | Medium |
| 5.2.1.6 | Longest Palindromic Substring [Do it without DP] | ❌ | Hard |
| 5.2.1.7 | Sum of Beauty of all substring | ❌ | Medium |
| 5.2.1.8 | Reverse Every Word in A String | ✅ | Easy |

---

# Step 6: Learn LinkedList [Single LL, Double LL, Medium, Hard Problems] (23/31)

## Lec 1: Learn 1D LinkedList (5/5 ✅)
| # | Problem | Solved | Difficulty |
|---|---------|--------|-----------|
| 6.1.1.1 | Introduction to LinkedList | ✅ | Easy |
| 6.1.1.2 | Inserting a node in LinkedList | ✅ | Easy |
| 6.1.1.3 | Deleting a node in LinkedList | ✅ | Medium |
| 6.1.1.4 | Find the length of the linkedlist | ✅ | Easy |
| 6.1.1.5 | Search an element in the LL | ✅ | Easy |

## Lec 2: Learn Doubly LinkedList (3/4)
| # | Problem | Solved | Difficulty |
|---|---------|--------|-----------|
| 6.2.1.1 | Introduction to DLL | ✅ | Easy |
| 6.2.1.2 | Insert a node in DLL | ✅ | Easy |
| 6.2.1.3 | Delete a node in DLL | ✅ | Medium |
| 6.2.1.4 | Reverse a DLL | ❌ | Medium |

## Lec 3: Medium Problems of LL (15/15 ✅)
| # | Problem | Solved | Difficulty |
|---|---------|--------|-----------|
| 6.3.1.1 | Middle of a LinkedList [TortoiseHare Method] | ✅ | Easy |
| 6.3.1.2 | Reverse a LinkedList [Iterative] | ✅ | Easy |
| 6.3.1.3 | Reverse a LL [Recursive] | ✅ | Easy |
| 6.3.1.4 | Detect a loop in LL | ✅ | Medium |
| 6.3.1.5 | Find the starting point in LL | ✅ | Medium |
| 6.3.1.6 | Length of Loop in LL | ✅ | Easy |
| 6.3.1.7 | Check if LL is palindrome or not | ✅ | Medium |
| 6.3.1.8 | Segregate odd and even nodes in LL | ✅ | Medium |
| 6.3.1.9 | Remove Nth node from the back of the LL | ✅ | Medium |
| 6.3.1.10 | Delete the middle node of LL | ✅ | Medium |
| 6.3.1.11 | Sort LL | ✅ | Medium |
| 6.3.1.12 | Sort a LL of 0's 1's and 2's by changing links | ✅ | Medium |
| 6.3.1.13 | Find the intersection point of Y LL | ✅ | Medium |
| 6.3.1.14 | Add 1 to a number represented by LL | ✅ | Medium |
| 6.3.1.15 | Add 2 numbers in LL | ✅ | Medium |

## Lec 4: Medium Problems of DLL (0/3)
| # | Problem | Solved | Difficulty |
|---|---------|--------|-----------|
| 6.4.1.1 | Delete all occurrences of a key in DLL | ❌ | Medium |
| 6.4.1.2 | Find pairs with given sum in DLL | ❌ | Medium |
| 6.4.1.3 | Remove duplicates from sorted DLL | ❌ | Medium |

## Lec 5: Hard Problems of LL (0/4)
| # | Problem | Solved | Difficulty |
|---|---------|--------|-----------|
| 6.5.1.1 | Reverse LL in group of given size K | ❌ | Hard |
| 6.5.1.2 | Rotate a LL | ❌ | Medium |
| 6.5.1.3 | Flattening of LL | ❌ | Hard |
| 6.5.1.4 | Clone a Linked List with random and next pointer | ❌ | Hard |

---

# Step 7: Recursion [PatternWise] (15/25)

## Lec 1: Get a Strong Hold (5/5 ✅)
| # | Problem | Solved | Difficulty |
|---|---------|--------|-----------|
| 7.1.1.1 | Recursive Implementation of atoi() | ✅ | Hard |
| 7.1.1.2 | Pow(x, n) | ✅ | Medium |
| 7.1.1.3 | Count Good numbers | ✅ | Easy |
| 7.1.1.4 | Sort a stack using recursion | ✅ | Medium |
| 7.1.1.5 | Reverse a stack using recursion | ✅ | Easy |

## Lec 2: Subsequences Pattern (8/12)
| # | Problem | Solved | Difficulty |
|---|---------|--------|-----------|
| 7.2.1.1 | Generate all binary strings | ❌ | Medium |
| 7.2.1.2 | Generate Paranthesis | ✅ | Medium |
| 7.2.1.3 | Print all subsequences/Power Set | ✅ | Medium |
| 7.2.1.4 | Learn All Patterns of Subsequences (Theory) | ❌ | Medium |
| 7.2.1.5 | Count all subsequences with sum K | ❌ | Hard |
| 7.2.1.6 | Check if there exists a subsequence with sum K | ❌ | Medium |
| 7.2.1.7 | Combination Sum | ✅ | Medium |
| 7.2.1.8 | Combination Sum-II | ✅ | Medium |
| 7.2.1.9 | Subset Sum-I | ✅ | Medium |
| 7.2.1.10 | Subset Sum-II | ✅ | Medium |
| 7.2.1.11 | Combination Sum - III | ✅ | Hard |
| 7.2.1.12 | Letter Combinations of a Phone number | ✅ | Medium |

## Lec 3: Trying out all Combos / Hard (2/8)
| # | Problem | Solved | Difficulty |
|---|---------|--------|-----------|
| 7.3.1.1 | Palindrome Partitioning | ❌ | Medium |
| 7.3.1.2 | Word Search | ✅ | Medium |
| 7.3.1.3 | N Queen | ✅ | Hard |
| 7.3.1.4 | Rat in a Maze | ❌ | Hard |
| 7.3.1.5 | Word Break | ❌ | (No difficulty listed) |
| 7.3.1.6 | M Coloring Problem | ❌ | Hard |
| 7.3.1.7 | Sudoko Solver | ❌ | Hard |
| 7.3.1.8 | Expression Add Operators | ❌ | Hard |

---

# Step 8: Bit Manipulation [Concepts & Problems] (13/18)

## Lec 1: Learn Bit Manipulation (8/8 ✅)
| # | Problem | Solved | Difficulty |
|---|---------|--------|-----------|
| 8.1.1.1 | Introduction to Bit Manipulation [Theory] | ✅ | Easy |
| 8.1.1.2 | Check if the i-th bit is set or not | ✅ | Easy |
| 8.1.1.3 | Check if a number is odd or not | ✅ | Easy |
| 8.1.1.4 | Check if a number is power of 2 or not | ✅ | Easy |
| 8.1.1.5 | Count the number of set bits | ✅ | Easy |
| 8.1.1.6 | Set/Unset the rightmost unset bit | ✅ | Easy |
| 8.1.1.7 | Swap two numbers | ✅ | Easy |
| 8.1.1.8 | Divide two integers without multiplication, division and mod | ✅ | Medium |

## Lec 2: Interview Problems (5/5 ✅)
| # | Problem | Solved | Difficulty |
|---|---------|--------|-----------|
| 8.2.1.1 | Count number of bits to be flipped to convert A to B | ✅ | Medium |
| 8.2.1.2 | Find the number that appears odd number of times | ✅ | Easy |
| 8.2.1.3 | Power Set | ✅ | Medium |
| 8.2.1.4 | Find xor of numbers from L to R | ✅ | Easy |
| 8.2.1.5 | Find the two numbers appearing odd number of times | ✅ | Easy |

## Lec 3: Advanced Maths (0/5)
| # | Problem | Solved | Difficulty |
|---|---------|--------|-----------|
| 8.3.1.1 | Print Prime Factors of a Number | ❌ | Easy |
| 8.3.1.2 | All Divisors of a Number | ❌ | Easy |
| 8.3.1.3 | Sieve of Eratosthenes | ❌ | Medium |
| 8.3.1.4 | Find Prime Factorisation of a Number using Sieve | ❌ | Medium |
| 8.3.1.5 | Power(n, x) | ❌ | Medium |

---

# Step 9: Stack and Queues [Learning, Pre-In-Post-fix, Monotonic Stack] (25/30)

## Lec 1: Learning (8/8 ✅)
| # | Problem | Solved | Difficulty |
|---|---------|--------|-----------|
| 9.1.1.1 | Implement Stack using Arrays | ✅ | Easy |
| 9.1.1.2 | Implement Queue using Arrays | ✅ | Easy |
| 9.1.1.3 | Implement Stack using Queue | ✅ | Medium |
| 9.1.1.4 | Implement Queue using Stack | ✅ | Medium |
| 9.1.1.5 | Implement stack using Linkedlist | ✅ | Easy |
| 9.1.1.6 | Implement queue using Linkedlist | ✅ | Medium |
| 9.1.1.7 | Check for balanced paranthesis | ✅ | Medium |
| 9.1.1.8 | Implement Min Stack | ✅ | Medium |

## Lec 2: Prefix, Infix, PostFix Conversion (6/6 ✅)
| # | Problem | Solved | Difficulty |
|---|---------|--------|-----------|
| 9.2.1.1 | Infix to Postfix Conversion using Stack | ✅ | Medium |
| 9.2.1.2 | Prefix to Infix Conversion | ✅ | Medium |
| 9.2.1.3 | Prefix to Postfix Conversion | ✅ | Medium |
| 9.2.1.4 | Postfix to Prefix Conversion | ✅ | Medium |
| 9.2.1.5 | Postfix to Infix | ✅ | Medium |
| 9.2.1.6 | Convert Infix To Prefix Notation | ✅ | Medium |

## Lec 3: Monotonic Stack/Queue Problems (11/11 ✅)
| # | Problem | Solved | Difficulty |
|---|---------|--------|-----------|
| 9.3.1.1 | Next Greater Element | ✅ | Easy |
| 9.3.1.2 | Next Greater Element 2 | ✅ | Medium |
| 9.3.1.3 | Next Smaller Element | ✅ | Easy |
| 9.3.1.4 | Number of NGEs to the right | ✅ | Medium |
| 9.3.1.5 | Trapping Rainwater | ✅ | Hard |
| 9.3.1.6 | Sum of subarray minimum | ✅ | Medium |
| 9.3.1.7 | Asteroid Collision | ✅ | Medium |
| 9.3.1.8 | Sum of subarray ranges | ✅ | Medium |
| 9.3.1.9 | Remove k Digits | ✅ | Medium |
| 9.3.1.10 | Largest rectangle in a histogram | ✅ | Medium |
| 9.3.1.11 | Maximal Rectangles | ✅ | Hard |

## Lec 4: Implementation Problems (0/5)
| # | Problem | Solved | Difficulty |
|---|---------|--------|-----------|
| 9.4.1.1 | Sliding Window maximum | ❌ | Hard |
| 9.4.1.2 | Stock span problem | ❌ | Medium |
| 9.4.1.3 | The Celebrity Problem | ❌ | Hard |
| 9.4.1.4 | LRU cache (IMPORTANT) | ❌ | Hard |
| 9.4.1.5 | LFU cache | ❌ | Hard |

---

# Step 10: Sliding Window & Two Pointer Combined Problems (3/12)

## Lec 1: Medium Problems (3/8)
| # | Problem | Solved | Difficulty |
|---|---------|--------|-----------|
| 10.1.1.1 | Longest Substring Without Repeating Characters | ✅ | Medium |
| 10.1.1.2 | Max Consecutive Ones III | ✅ | Medium |
| 10.1.1.3 | Fruit Into Baskets | ❌ | Medium |
| 10.1.1.4 | longest repeating character replacement | ❌ | Medium |
| 10.1.1.5 | Binary subarray with sum | ❌ | Easy |
| 10.1.1.6 | Count number of nice subarrays | ❌ | Medium |
| 10.1.1.7 | Number of substring containing all three characters | ❌ | Medium |
| 10.1.1.8 | Maximum point you can obtain from cards | ✅ | Medium |

## Lec 2: Hard Problems (0/4)
| # | Problem | Solved | Difficulty |
|---|---------|--------|-----------|
| 10.2.1.1 | Longest Substring with At Most K Distinct Characters | ❌ | Medium |
| 10.2.1.2 | Subarray with k different integers | ❌ | Hard |
| 10.2.1.3 | Minimum Window Substring | ❌ | Hard |
| 10.2.1.4 | Minimum Window Subsequence | ❌ | Hard |

---

# Step 11: Heaps [Learning, Medium, Hard Problems] (4/17)

## Lec 1: Learning (4/4 ✅)
| # | Problem | Solved | Difficulty |
|---|---------|--------|-----------|
| 11.1.1.1 | Introduction to Priority Queues using Binary Heaps | ✅ | Medium |
| 11.1.1.2 | Min Heap and Max Heap Implementation | ✅ | Medium |
| 11.1.1.3 | Check if an array represents a min-heap or not | ✅ | Medium |
| 11.1.1.4 | Convert min Heap to max Heap | ✅ | Medium |

## Lec 2: Medium Problems (0/7)
| # | Problem | Solved | Difficulty |
|---|---------|--------|-----------|
| 11.2.1.1 | Kth largest element in an array [use priority queue] | ❌ | Easy |
| 11.2.1.2 | Kth smallest element in an array [use priority queue] | ❌ | Easy |
| 11.2.1.3 | Sort K sorted array | ❌ | Easy |
| 11.2.1.4 | Merge M sorted Lists | ❌ | Hard |
| 11.2.1.5 | Replace each array element by its corresponding rank | ❌ | Easy |
| 11.2.1.6 | Task Scheduler | ❌ | Medium |
| 11.2.1.7 | Hands of Straights | ❌ | Medium |

## Lec 3: Hard Problems (0/6)
| # | Problem | Solved | Difficulty |
|---|---------|--------|-----------|
| 11.3.1.1 | Design twitter | ❌ | Medium |
| 11.3.1.2 | Connect `n` ropes with minimal cost | ❌ | Medium |
| 11.3.1.3 | Kth largest element in a stream of running integers | ❌ | Easy |
| 11.3.1.4 | Maximum Sum Combination | ❌ | Medium |
| 11.3.1.5 | Find Median from Data Stream | ❌ | Hard |
| 11.3.1.6 | K most frequent elements | ❌ | Medium |

---

# Step 12: Greedy Algorithms [Easy, Medium/Hard] (10/16)

## Lec 1: Easy Problems (2/5)
| # | Problem | Solved | Difficulty |
|---|---------|--------|-----------|
| 12.1.1.1 | Assign Cookies | ✅ | Easy |
| 12.1.1.2 | Fractional Knapsack Problem | ❌ | Medium |
| 12.1.1.3 | Greedy algorithm to find minimum number of coins | ❌ | Medium |
| 12.1.1.4 | Lemonade Change | ✅ | Easy |
| 12.1.1.5 | Valid Paranthesis Checker | ❌ | Medium |

## Lec 2: Medium/Hard (8/11)
| # | Problem | Solved | Difficulty |
|---|---------|--------|-----------|
| 12.2.1.1 | N meetings in one room | ✅ | Medium |
| 12.2.1.2 | Jump Game | ✅ | Medium |
| 12.2.1.3 | Jump Game 2 | ✅ | Medium |
| 12.2.1.4 | Minimum number of platforms required for a railway | ❌ | Medium |
| 12.2.1.5 | Job sequencing Problem | ✅ | Medium |
| 12.2.1.6 | Candy | ❌ | Hard |
| 12.2.1.7 | Program for Shortest Job First (or SJF) CPU Scheduling | ✅ | Medium |
| 12.2.1.8 | Program for Least Recently Used (LRU) Page Replacement | ❌ | Medium |
| 12.2.1.9 | Insert Interval | ✅ | Medium |
| 12.2.1.10 | Merge Intervals | ✅ | Medium |
| 12.2.1.11 | Non-overlapping Intervals | ✅ | Medium |

---

# Step 13: Binary Trees [Traversals, Medium and Hard Problems] (27/39)

## Lec 1: Traversals (11/13)
| # | Problem | Solved | Difficulty |
|---|---------|--------|-----------|
| 13.1.1.1 | Introduction to Trees | ✅ | Easy |
| 13.1.1.2 | Binary Tree Representation in C++ | ✅ | Easy |
| 13.1.1.3 | Binary Tree Representation in Java | ❌ | Easy |
| 13.1.1.4 | Binary Tree Traversals in Binary Tree | ✅ | Easy |
| 13.1.1.5 | Preorder Traversal of Binary Tree | ✅ | Easy |
| 13.1.1.6 | Inorder Traversal of Binary Tree | ✅ | Easy |
| 13.1.1.7 | Post-order Traversal of Binary Tree | ✅ | Easy |
| 13.1.1.8 | Level order Traversal / Level order traversal in spiral form | ✅ | Easy |
| 13.1.1.9 | Iterative Preorder Traversal of Binary Tree | ✅ | Easy |
| 13.1.1.10 | Iterative Inorder Traversal of Binary Tree | ✅ | Easy |
| 13.1.1.11 | Post-order Traversal of Binary Tree using 2 stack | ✅ | Easy |
| 13.1.1.12 | Post-order Traversal of Binary Tree using 1 stack | ❌ | Medium |
| 13.1.1.13 | Preorder, Inorder, and Postorder Traversal in one Traversal | ❌ | Medium |

## Lec 2: Medium Problems (12/12 ✅)
| # | Problem | Solved | Difficulty |
|---|---------|--------|-----------|
| 13.2.1.1 | Height of a Binary Tree | ✅ | Medium |
| 13.2.1.2 | Check if the Binary tree is height-balanced or not | ✅ | Medium |
| 13.2.1.3 | Diameter of Binary Tree | ✅ | Medium |
| 13.2.1.4 | Maximum path sum | ✅ | Hard |
| 13.2.1.5 | Check if two trees are identical or not | ✅ | Medium |
| 13.2.1.6 | Zig Zag Traversal of Binary Tree | ✅ | Easy |
| 13.2.1.7 | Boundary Traversal of Binary Tree | ✅ | Medium |
| 13.2.1.8 | Vertical Order Traversal of Binary Tree | ✅ | Easy |
| 13.2.1.9 | Top View of Binary Tree | ✅ | Easy |
| 13.2.1.10 | Bottom View of Binary Tree | ✅ | Medium |
| 13.2.1.11 | Right/Left View of Binary Tree | ✅ | Medium |
| 13.2.1.12 | Symmetric Binary Tree | ✅ | Medium |

## Lec 3: Hard Problems (4/14)
| # | Problem | Solved | Difficulty |
|---|---------|--------|-----------|
| 13.3.1.1 | Root to Node Path in Binary Tree | ❌ | Medium |
| 13.3.1.2 | LCA in Binary Tree | ✅ | Medium |
| 13.3.1.3 | Maximum width of a Binary Tree | ❌ | Medium |
| 13.3.1.4 | Check for Children Sum Property | ❌ | Hard |
| 13.3.1.5 | Print all the Nodes at a distance of K in a Binary Tree | ✅ | Medium |
| 13.3.1.6 | Minimum time taken to BURN the Binary Tree from a Node | ❌ | Hard |
| 13.3.1.7 | Count total Nodes in a COMPLETE Binary Tree | ❌ | Medium |
| 13.3.1.8 | Requirements needed to construct a Unique Binary Tree Theory | ❌ | Medium |
| 13.3.1.9 | Construct Binary Tree from inorder and preorder | ✅ | Hard |
| 13.3.1.10 | Construct the Binary Tree from Postorder and Inorder Traversal | ✅ | Hard |
| 13.3.1.11 | Serialize and deserialize Binary Tree | ❌ | Hard |
| 13.3.1.12 | Morris Preorder Traversal of a Binary Tree | ❌ | Medium |
| 13.3.1.13 | Morris Inorder Traversal of a Binary Tree | ❌ | Medium |
| 13.3.1.14 | Flatten Binary Tree to LinkedList | ✅ | Hard |

---

# Step 14: Binary Search Trees [Concept and Problems] (10/16)

## Lec 1: Concepts (3/3 ✅)
| # | Problem | Solved | Difficulty |
|---|---------|--------|-----------|
| 14.1.1.1 | Introduction to Binary Search Tree | ✅ | Easy |
| 14.1.1.2 | Search in a Binary Search Tree | ✅ | Easy |
| 14.1.1.3 | Find Min/Max in BST | ✅ | Medium |

## Lec 2: Practice Problems (7/13)
| # | Problem | Solved | Difficulty |
|---|---------|--------|-----------|
| 14.2.1.1 | Ceil in a Binary Search Tree | ✅ | Easy |
| 14.2.1.2 | Floor in a Binary Search Tree | ✅ | Easy |
| 14.2.1.3 | Insert a given Node in Binary Search Tree | ✅ | Easy |
| 14.2.1.4 | Delete a Node in Binary Search Tree | ✅ | Medium |
| 14.2.1.5 | Find K-th smallest/largest element in BST | ❌ | Medium |
| 14.2.1.6 | Check if a tree is a BST or BT | ✅ | Medium |
| 14.2.1.7 | LCA in Binary Search Tree | ✅ | Medium |
| 14.2.1.8 | Construct a BST from a preorder traversal | ✅ | Medium |
| 14.2.1.9 | Inorder Successor/Predecessor in BST | ❌ | Medium |
| 14.2.1.10 | Merge 2 BST's | ❌ | Hard |
| 14.2.1.11 | Two Sum In BST - Check if there exists a pair with Sum K | ❌ | Medium |
| 14.2.1.12 | Recover BST - Correct BST with two nodes swapped | ❌ | Hard |
| 14.2.1.13 | Largest BST in Binary Tree | ❌ | Hard |

---

# Step 15: Graphs [Concepts & Problems] (33/54)

## Lec 1: Learning (4/6)
| # | Problem | Solved | Difficulty |
|---|---------|--------|-----------|
| 15.1.1.1 | Graph and Types | ✅ | Easy |
| 15.1.1.2 | Graph Representation - C++ | ✅ | Easy |
| 15.1.1.3 | Graph Representation - Java | ❌ | Easy |
| 15.1.1.4 | Connected Components - Logic Explanation | ❌ | Hard |
| 15.1.1.5 | BFS | ✅ | Medium |
| 15.1.1.6 | DFS | ✅ | Hard |

## Lec 2: Problems on BFS/DFS (11/14)
| # | Problem | Solved | Difficulty |
|---|---------|--------|-----------|
| 15.2.1.1 | Number of provinces (leetcode) | ✅ | Medium |
| 15.2.1.2 | Connected Components Problem in Matrix | ✅ | Hard |
| 15.2.1.3 | Rotten Oranges | ✅ | Medium |
| 15.2.1.4 | Flood fill | ✅ | Hard |
| 15.2.1.5 | Cycle Detection in Undirected Graph (bfs) | ✅ | Hard |
| 15.2.1.6 | Cycle Detection in Undirected Graph (dfs) | ✅ | Hard |
| 15.2.1.7 | 0/1 Matrix (Bfs Problem) | ✅ | Medium |
| 15.2.1.8 | Surrounded Regions (dfs) | ✅ | Hard |
| 15.2.1.9 | Number of Enclaves [flood fill implementation] | ✅ | Hard |
| 15.2.1.10 | Word ladder - 1 | ✅ | Hard |
| 15.2.1.11 | Word ladder - 2 | ✅ | Hard |
| 15.2.1.12 | Number of Distinct Islands [dfs multisource] | ❌ | Hard |
| 15.2.1.13 | Bipartite Graph (DFS) | ❌ | Medium |
| 15.2.1.14 | Cycle Detection in Directed Graph (DFS) | ❌ | Hard |

## Lec 3: Topo Sort and Problems (5/7)
| # | Problem | Solved | Difficulty |
|---|---------|--------|-----------|
| 15.3.1.1 | Topo Sort | ✅ | Hard |
| 15.3.1.2 | Kahn's Algorithm | ✅ | Hard |
| 15.3.1.3 | Cycle Detection in Directed Graph (BFS) | ✅ | Hard |
| 15.3.1.4 | Course Schedule - I | ✅ | Hard |
| 15.3.1.5 | Course Schedule - II | ✅ | Hard |
| 15.3.1.6 | Find eventual safe states | ❌ | Hard |
| 15.3.1.7 | Alien dictionary | ❌ | Hard |

## Lec 4: Shortest Path Algorithms and Problems (9/13)
| # | Problem | Solved | Difficulty |
|---|---------|--------|-----------|
| 15.4.1.1 | Shortest Path in UG with unit weights | ✅ | Hard |
| 15.4.1.2 | Shortest Path in DAG | ✅ | Hard |
| 15.4.1.3 | Dijkstra's Algorithm | ✅ | Hard |
| 15.4.1.4 | Why priority Queue is used in Dijkstra's Algorithm | ✅ | Medium |
| 15.4.1.5 | Shortest path in a binary maze | ✅ | Medium |
| 15.4.1.6 | Path with minimum effort | ✅ | Medium |
| 15.4.1.7 | Cheapest flights within k stops | ✅ | Hard |
| 15.4.1.8 | Network Delay time | ✅ | Medium |
| 15.4.1.9 | Number of ways to arrive at destination | ✅ | Medium |
| 15.4.1.10 | Minimum steps to reach end from start | ❌ | Hard |
| 15.4.1.11 | Bellman Ford Algorithm | ❌ | Hard |
| 15.4.1.12 | Floyd Warshal Algorithm | ❌ | Hard |
| 15.4.1.13 | Find the city with the smallest number of neighbors | ❌ | Hard |

## Lec 5: MinimumSpanningTree/Disjoint Set and Problems (4/11)
| # | Problem | Solved | Difficulty |
|---|---------|--------|-----------|
| 15.5.1.1 | Minimum Spanning Tree | ✅ | Hard |
| 15.5.1.2 | Prim's Algorithm | ✅ | Hard |
| 15.5.1.3 | Disjoint Set [Union by Rank] | ✅ | Hard |
| 15.5.1.4 | Disjoint Set [Union by Size] | ✅ | Hard |
| 15.5.1.5 | Kruskal's Algorithm | ❌ | Hard |
| 15.5.1.6 | Number of operations to make network connected | ❌ | Medium |
| 15.5.1.7 | Most stones removed with same rows or columns | ❌ | Medium |
| 15.5.1.8 | Accounts merge | ❌ | Hard |
| 15.5.1.9 | Number of island II | ❌ | Hard |
| 15.5.1.10 | Making a Large Island | ❌ | Hard |
| 15.5.1.11 | Swim in rising water | ❌ | Hard |

## Lec 6: Other Algorithms (0/3)
| # | Problem | Solved | Difficulty |
|---|---------|--------|-----------|
| 15.6.1.1 | Bridges in Graph | ❌ | Hard |
| 15.6.1.2 | Articulation Point | ❌ | Hard |
| 15.6.1.3 | Kosaraju's Algorithm | ❌ | Hard |

---

# Step 16: Dynamic Programming [Patterns and Problems] (46/56 - 82%)

## Lec 1: Introduction to DP (1/1 ✅)

| # | Problem | Solved | Difficulty | Notes |
|---|---------|--------|-----------|-------|
| 16.1.1.1 | Dynamic Programming Introduction | ✅ | Medium | Understanding memoization, recursion, tabulation |

---

## Lec 2: 1D DP (5/5 ✅)

| # | Problem | Solved | Difficulty | Pattern |
|---|---------|--------|-----------|---------|
| 16.2.1.1 | Climbing Stairs | ✅ | Medium | dp[i] = dp[i-1] + dp[i-2] |
| 16.2.1.2 | Frog Jump (DP-3) | ✅ | Medium | Jump 1 or 2 steps, minimize energy |
| 16.2.1.3 | Frog Jump with K distances (DP-4) | ✅ | Medium | Jump up to K steps forward |
| 16.2.1.4 | Maximum sum of non-adjacent elements (DP-5) | ✅ | Medium | House Robber - don't take adjacent |
| 16.2.1.5 | House Robber (DP-6) | ✅ | Medium | Circular houses variant |

---

## Lec 3: 2D/3D DP and DP on Grids (7/7 ✅)

| # | Problem | Solved | Difficulty | Pattern |
|---|---------|--------|-----------|---------|
| 16.3.1.1 | Ninja's Training (DP-7) | ✅ | Medium | 3D DP: activities × days × prev choice |
| 16.3.1.2 | Grid Unique Paths (DP-8) | ✅ | Medium | dp[i][j] = dp[i-1][j] + dp[i][j-1] |
| 16.3.1.3 | Grid Unique Paths 2 (DP-9) | ✅ | Medium | Grid with obstacles |
| 16.3.1.4 | Minimum path sum in Grid (DP-10) | ✅ | Medium | Start top-left, reach bottom-right |
| 16.3.1.5 | Minimum path sum in Triangular Grid (DP-11) | ✅ | Medium | Triangle traversal from top to bottom |
| 16.3.1.6 | Minimum/Maximum Falling Path Sum (DP-12) | ✅ | Medium | Can move to 3 cells below |
| 16.3.1.7 | 3D DP: Ninja and his friends (DP-13) | ✅ | Medium | Multiple paths in 2D grid simultaneously |

---

## Lec 4: DP on Subsequences (8/11)

| # | Problem | Solved | Difficulty | Pattern |
|---|---------|--------|-----------|---------|
| 16.4.1.1 | Subset sum equal to target (DP-14) | ✅ | Medium | 0/1 Knapsack: pick/exclude elements |
| 16.4.1.2 | Partition Equal Subset Sum (DP-15) | ✅ | Medium | Check if can partition into 2 equal sum subsets |
| 16.4.1.3 | Partition Set Into 2 Subsets With Min Absolute Sum Diff (DP-16) | ❌ | Medium | Minimize |sum1 - sum2| |
| 16.4.1.4 | Count Subsets with Sum K (DP-17) | ✅ | Medium | Count ways to form sum K |
| 16.4.1.5 | Count Partitions with Given Difference (DP-18) | ✅ | Medium | Partition into 2 sets with diff = D |
| 16.4.1.6 | Assign Cookies (Greedy DP variant) | ✅ | Hard | Coin change extension |
| 16.4.1.7 | Minimum Coins (DP-20) | ✅ | Hard | Unbounded: fewest coins for amount |
| 16.4.1.8 | Target Sum (DP-21) | ✅ | Medium | Place +/- to achieve target |
| 16.4.1.9 | Coin Change 2 (DP-22) | ✅ | Hard | Count ways to make amount |
| 16.4.1.10 | Unbounded Knapsack (DP-23) | ❌ | Hard | Take items unlimited times |
| 16.4.1.11 | Rod Cutting Problem (DP-24) | ❌ | Hard | Cut rod to maximize profit |

---

## Lec 5: DP on Strings (8/10)

| # | Problem | Solved | Difficulty | Pattern |
|---|---------|--------|-----------|---------|
| 16.5.1.1 | Longest Common Subsequence (DP-25) | ✅ | Hard | dp[i][j] = LCS(s1[0..i], s2[0..j]) |
| 16.5.1.2 | Print Longest Common Subsequence (DP-26) | ✅ | Hard | Reconstruct LCS from DP table |
| 16.5.1.3 | Longest Common Substring (DP-27) | ❌ | Hard | Continuous match (not subsequence) |
| 16.5.1.4 | Longest Palindromic Subsequence (DP-28) | ✅ | Hard | LCS(s, reverse(s)) |
| 16.5.1.5 | Minimum insertions to make string palindrome (DP-29) | ✅ | Hard | n - LPS (Longest Palindromic Subseq) |
| 16.5.1.6 | Minimum Insertions/Deletions to Convert String (DP-30) | ✅ | Hard | Edit distance: only insert/delete |
| 16.5.1.7 | Shortest Common Supersequence (DP-31) | ✅ | Hard | Reconstruct from LCS |
| 16.5.1.8 | Distinct Subsequences (DP-32) | ✅ | Hard | Count unique subsequences of s1 in s2 |
| 16.5.1.9 | Edit Distance (DP-33) | ✅ | Hard | Levenshtein: insert/delete/replace |
| 16.5.1.10 | Wildcard Matching (DP-34) | ❌ | Medium | '*' = any chars, '?' = single char |

---

## Lec 6: DP on Stocks (4/6)

| # | Problem | Solved | Difficulty | Pattern |
|---|---------|--------|-----------|---------|
| 16.6.1.1 | Best Time to Buy and Sell Stock (DP-35) | ✅ | Hard | 1 transaction allowed |
| 16.6.1.2 | Buy and Sell Stock - II (DP-36) | ✅ | Hard | Unlimited transactions |
| 16.6.1.3 | Buy and Sell Stocks III (DP-37) | ✅ | Hard | Max 2 transactions |
| 16.6.1.4 | Buy and Sell Stock IV (DP-38) | ✅ | Hard | Max K transactions |
| 16.6.1.5 | Buy and Sell Stocks With Cooldown (DP-39) | ❌ | Hard | Cooldown after each sale |
| 16.6.1.6 | Buy and Sell Stocks With Transaction Fee (DP-40) | ❌ | Hard | Each transaction has fee |

---

## Lec 7: DP on LIS (7/7 ✅)

| # | Problem | Solved | Difficulty | Pattern |
|---|---------|--------|-----------|---------|
| 16.7.1.1 | Longest Increasing Subsequence (DP-41) | ✅ | Hard | O(n²) approach |
| 16.7.1.2 | Printing Longest Increasing Subsequence (DP-42) | ✅ | Hard | Reconstruct LIS |
| 16.7.1.3 | Longest Increasing Subsequence with Binary Search (DP-43) | ✅ | Hard | O(n log n) approach |
| 16.7.1.4 | Largest Divisible Subset (DP-44) | ✅ | Hard | Find largest subset where each divides next |
| 16.7.1.5 | Longest String Chain (DP-45) | ✅ | Hard | Chain of words differing by 1 character |
| 16.7.1.6 | Longest Bitonic Subsequence (DP-46) | ✅ | Hard | Increase then decrease |
| 16.7.1.7 | Number of Longest Increasing Subsequences (DP-47) | ✅ | Hard | Count distinct LIS |

---

## Lec 8: MCM DP / Partition DP (4/7)

| # | Problem | Solved | Difficulty | Pattern |
|---|---------|--------|-----------|---------|
| 16.8.1.1 | Matrix Chain Multiplication (DP-48) | ✅ | Hard | Memoization: find optimal multiplication order |
| 16.8.1.2 | Matrix Chain Multiplication - Bottom-Up (DP-49) | ✅ | Hard | Tabulation approach |
| 16.8.1.3 | Minimum Cost to Cut the Stick (DP-50) | ✅ | Hard | Partition DP: optimal cut positions |
| 16.8.1.4 | Burst Balloons (DP-51) | ✅ | Hard | Reverse thinking: think of keeping balloons |
| 16.8.1.5 | Evaluate Boolean Expression to True (DP-52) | ❌ | Hard | Count ways to place parentheses for true result |
| 16.8.1.6 | Palindrome Partitioning - II (DP-53) | ❌ | Hard | Min cuts to make palindromic parts |
| 16.8.1.7 | Partition Array for Maximum Sum (DP-54) | ❌ | Hard | Partition and replace with max |

---

## Lec 9: DP on Squares (2/2 ✅)

| # | Problem | Solved | Difficulty | Pattern |
|---|---------|--------|-----------|---------|
| 16.9.1.1 | Maximum Rectangle Area with all 1's (DP-55) | ✅ | Hard | Largest rectangle in histogram DP |
| 16.9.1.2 | Count Square Submatrices with All Ones (DP-56) | ✅ | Hard | dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 |

---

# Step 17: Tries [Data Structure for Prefix Matching] (1/7 - 14%)

## Lec 1: Theory (1/1 ✅)

| # | Problem | Solved | Difficulty | Key Concepts |
|---|---------|--------|-----------|--------------|
| 17.1.1.1 | Implement TRIE - INSERT, SEARCH, STARTSWITH | ✅ | Hard | Node structure, path traversal, end markers |

---

## Lec 2: Problems (0/6)

| # | Problem | Solved | Difficulty | Key Concepts |
|---|---------|--------|-----------|--------------|
| 17.2.1.1 | Implement Trie - 2 (Prefix Tree with counts) | ❌ | Hard | Count prefix occurrences, deletion logic |
| 17.2.1.2 | Longest String with All Prefixes | ❌ | Medium | Build string incrementally with valid prefixes |
| 17.2.1.3 | Number of Distinct Substrings in a String | ❌ | Hard | Insert all substrings, count Trie nodes |
| 17.2.1.4 | Bit PreRequisites for TRIE Problems | ❌ | Hard | Bit manipulation for XOR problems |
| 17.2.1.5 | Maximum XOR of two numbers in an array | ❌ | Medium | Binary Trie: store binary representation |
| 17.2.1.6 | Maximum XOR With an Element From Array | ❌ | Hard | Filter by queries < x, use Trie for max XOR |

---

# Step 18: Strings [Advanced Pattern Matching & Algorithms] (0/9 - 0%)

## Lec 1: Hard Problems (0/9)

| # | Problem | Solved | Difficulty | Algorithm/Pattern |
|---|---------|--------|-----------|-------------------|
| 18.1.1.1 | Minimum bracket reversals to balance expression | ❌ | Medium | Stack-based counting or DP |
| 18.1.1.2 | Count and Say (Look and Say Sequence) | ❌ | Medium | Consecutive character counting |
| 18.1.1.3 | Hashing In Strings [Theory] | ❌ | Medium | Polynomial rolling hash |
| 18.1.1.4 | Rabin Karp Algorithm | ❌ | Hard | Rolling hash for pattern matching |
| 18.1.1.5 | Z-Function | ❌ | Easy | Linear time string matching |
| 18.1.1.6 | KMP Algorithm / LPS Array | ❌ | Hard | Knuth-Morris-Pratt failure function |
| 18.1.1.7 | Shortest Palindrome | ❌ | Hard | KMP or Manacher's algorithm |
| 18.1.1.8 | Longest Happy Prefix | ❌ | Hard | KMP LPS array application |
| 18.1.1.9 | Count Palindromic Subsequences | ❌ | Hard | DP with character tracking |
